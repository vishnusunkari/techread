{"componentChunkName":"component---src-templates-docs-js","path":"/java/01-java-functional-programming","result":{"data":{"site":{"siteMetadata":{"title":"TechGry","docsLocation":""}},"mdx":{"fields":{"id":"01e47731-9b23-5961-afd1-af275dd9bea8","title":"Functional Programming","slug":"/java/01-java-functional-programming"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Functional Programming\",\n  \"metaTitle\": \"Functional Programming in Java\",\n  \"metaDescription\": \"Functional Programming in Java, Lambda expressions, Functional Interfaces,  Real use of lambdas and method references, Java Stream Operations, Java Stream examples,  Highest salary using java stream,  Distinct integers in a list using java stream, List to Map using java stream\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"Functional Interfaces in Java (Lambda)\"), mdx(\"p\", null, \"Every Lambda expression has 3 parts:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"()  Argument List \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"-> token\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"{ } Body\")), mdx(\"p\", null, \"Lambda expressions only work for Functional Interfaces. eg:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Runnable and Callable (Multi-threading)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"ActionListener (GUIs)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Comparable and Comparator (Sorting objects, Pure Functional Interface) \")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Comparator <Employee> nameComparator = (a, b) -> a.getName().compareTo(b.getName());\\n\")), mdx(\"h3\", null, \"Functional Interfaces, by Function Type\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Function Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Function Name\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"nothing -> T\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Supplier\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"T -> nothing\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Consumer\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"T -> T\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Unary Operator\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"T, T -> T\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Binary Operator\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"S -> T\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Function\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"T -> boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Predicate\")))), mdx(\"p\", null, \"What is the real use of Lambdas and Method References ?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"They are 2 handy ways to pass code around.  \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lambdas for short snippets of code.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method References for longer pieces of code for methods that are already part of a larger architecture.\")), mdx(\"h3\", null, \"Streams\"), mdx(\"p\", null, \"Unlike external iteration in for and while loops, java streams uses internal iteration,\\nmeaning apply some operation on every object of the sequence.\\nYou pass a functional object to the forEach method and the forEach method takes care of\\niteration.  It is internal because the responsibility of iteration lies within the collection,\\nin this case stream. ie responsibility shifts from client to stream library.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Employee [] emps = { emp1, emp2, emp3 ..}\\nArrays.stream(emps).fitler(e->e.getSalary() >= 2500)\\n                   .map(Employee::getName)\\n                   .sorted()\\n                   .forEach(System.out::println);\\n\\nStream.of(emps).filter ....\\n\")), mdx(\"h3\", null, \"Stream Operations\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"filter: is to  filter the result based on predicate\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"map:  is to extract based on the given method on object\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"sorted:  is to sort\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"forEach:  is terminal operator to print\")), mdx(\"h3\", null, \"Stream Characteristics\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Streams can be ordered or unordered.  \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Streams from lists are ordered. Streams from sets are unordered\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Streams can be sequential or parallel.  \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Streams can only be traversed Once.\")), mdx(\"h3\", null, \"Filtering Operations of Java Streams\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Based on Content : filter, takeWhile, dropWhile  (takeWhile & dropWhile makes sense for ordered streams) \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Based on Amount: limit\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Based on Uniqueness: distinct\")), mdx(\"h3\", null, \"distinct() operation on streams\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is better to operate distinct() operation on as few elements as possible as it is more complex.   \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is one of the few stateful intermediate operations.    \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It does not operate independently on each element.   \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Harder to parallelize.\")), mdx(\"h3\", null, \"Terminal Operations in Stream\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Return Type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Function\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"void\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"forEach, forEachOrdered, peek (intermediate operation, for debugging)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"boolean\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"allMatch, anyMatch, noneMatch\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"array\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"toArray\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"long\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"count\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"T\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"findFirst, findAny, min, max\")))), mdx(\"h3\", null, \"Examples of Java Stream Operations\"), mdx(\"p\", null, \"Q. Print names of 10  employees with the highest salary using java stream\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"A. emps.sorted(Comparator.comparingInt(Employee::getSalary).reversed())\\n       .limit(10)\\n       .map(Employee::getName)\\n       .forEachOrdered(System.out::println)\\n\")), mdx(\"p\", null, \"Q. Count the number of distinct integers in a list using java stream\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"long n = list.parallelStream().  (this stream is natunally ordered(from List))\\n             .unordered().     (relaxing the order gives significant speedup)\\n             .distinct()\\n             .count();\\n\")), mdx(\"p\", null, \"Q. List to Map using java stream    \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Extract map with departmentId as key  and List<employeeId> as values: \\nMap<Long, List<Long>> deptIdToEmpIdMap =  \\n        items.stream()\\n             .collect(\\n                 Collectors.groupingBy(\\n                     Department::id, \\n                     Collectors.mapping(\\n                         Employee::getEmployeeId, \\n                         Collectors.toList()\\n                     )\\n                 )\\n             );\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#functional-interfaces-in-java-lambda","title":"Functional Interfaces in Java (Lambda)"},{"url":"#functional-interfaces-by-function-type","title":"Functional Interfaces, by Function Type"},{"url":"#streams","title":"Streams"},{"url":"#stream-operations","title":"Stream Operations"},{"url":"#stream-characteristics","title":"Stream Characteristics"},{"url":"#filtering-operations-of-java-streams","title":"Filtering Operations of Java Streams"},{"url":"#distinct-operation-on-streams","title":"distinct() operation on streams"},{"url":"#terminal-operations-in-stream","title":"Terminal Operations in Stream"},{"url":"#examples-of-java-stream-operations","title":"Examples of Java Stream Operations"}]},"parent":{"__typename":"File","relativePath":"java/01-java-functional-programming.md"},"frontmatter":{"metaTitle":"Functional Programming in Java","metaDescription":"Functional Programming in Java, Lambda expressions, Functional Interfaces,  Real use of lambdas and method references, Java Stream Operations, Java Stream examples,  Highest salary using java stream,  Distinct integers in a list using java stream, List to Map using java stream"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/concepts","title":"RealWorld Concepts"}}},{"node":{"fields":{"slug":"/java","title":"Java"}}},{"node":{"fields":{"slug":"/aws","title":"AWS"}}},{"node":{"fields":{"slug":"/kafka","title":"Kafka Concepts"}}},{"node":{"fields":{"slug":"/kubernetes","title":"Kubernetes Concepts"}}},{"node":{"fields":{"slug":"/pages/about","title":"About TechGry"}}},{"node":{"fields":{"slug":"/pages/terms-and-conditions","title":"Terms and Conditions"}}},{"node":{"fields":{"slug":"/pages/about-me","title":"Vishnu Sunkari"}}},{"node":{"fields":{"slug":"/pages/disclaimer","title":"Disclaimer"}}},{"node":{"fields":{"slug":"/kafka/00-what-is-kafka","title":"What is Kafka"}}},{"node":{"fields":{"slug":"/pages/privacypolicy","title":"Privacy Policy"}}},{"node":{"fields":{"slug":"/kafka/02-kafka-brokers","title":"Brokers"}}},{"node":{"fields":{"slug":"/kubernetes/01-more-pods-on-nodes","title":"How to deploy more pods on kubernetes nodes"}}},{"node":{"fields":{"slug":"/kafka/03-kafka-producers","title":"Producers"}}},{"node":{"fields":{"slug":"/kafka/04-kafka-consumers","title":"Kafka Consumers"}}},{"node":{"fields":{"slug":"/kafka/01-kafka-topics-partitions-offsets","title":"Topics,Partitions & Offsets"}}},{"node":{"fields":{"slug":"/kafka/05-kafka-consumer-offsets-delivery","title":"Consumer Offsets and Delivery Semantics"}}},{"node":{"fields":{"slug":"/kafka/09-kafka-how-to-build-distributed-scalable-system","title":"How to build distributed scalable system with Kafka"}}},{"node":{"fields":{"slug":"/kafka/07-kafka-guarantees","title":"Kafka Guarantees"}}},{"node":{"fields":{"slug":"/kafka/08-kafka-concepts-summary","title":"Kafka Concepts Summary"}}},{"node":{"fields":{"slug":"/java/01-java-functional-programming","title":"Functional Programming"}}},{"node":{"fields":{"slug":"/kafka/06-kafka-broker-discovery-zookeeper","title":"Kafka Broker Discovery and Zookeeper"}}},{"node":{"fields":{"slug":"/java/00-java-classloaders","title":"Java ClassLoaders"}}},{"node":{"fields":{"slug":"/concepts/00-rotation-strategy","title":"Rotate Monthly"}}},{"node":{"fields":{"slug":"/concepts/01-apis-security","title":"API Security"}}},{"node":{"fields":{"slug":"/concepts/02-maxLifetime","title":"Fix HikariPool"}}},{"node":{"fields":{"slug":"/concepts/03-access-spring-beans","title":"Spring Beans"}}},{"node":{"fields":{"slug":"/concepts/04-save-queue-data-on-to-disk","title":"Saving Queue Data on to Disk"}}},{"node":{"fields":{"slug":"/aws/01-aws-organizations","title":"AWS Organizations"}}},{"node":{"fields":{"slug":"/aws/03-aws-service-catalog","title":"AWS Service Catalog"}}},{"node":{"fields":{"slug":"/aws/04-aws-systems-manager","title":"AWS Systems Manager"}}},{"node":{"fields":{"slug":"/aws/00-aws-iam","title":"IAM"}}},{"node":{"fields":{"slug":"/aws/02-aws-config","title":"AWS Config"}}},{"node":{"fields":{"slug":"/aws/05-aws-elastic-load-balancing","title":"Elastic Load Balancing"}}},{"node":{"fields":{"slug":"/aws/06-aws-autoscaling","title":"Autoscaling"}}},{"node":{"fields":{"slug":"/aws/07-aws-placement-groups","title":"Placement Groups"}}},{"node":{"fields":{"slug":"/aws/08-aws-cloudfront","title":"CloudFront"}}},{"node":{"fields":{"slug":"/aws/09-aws-route53","title":"Route53"}}},{"node":{"fields":{"slug":"/aws/10-aws-s3","title":"S3"}}},{"node":{"fields":{"slug":"/aws/11-aws-efs","title":"EFS"}}},{"node":{"fields":{"slug":"/aws/15-aws-elasticbeanstalk","title":"Elastic Beanstalk"}}},{"node":{"fields":{"slug":"/aws/14-aws-opsworks","title":"OpsWorks"}}},{"node":{"fields":{"slug":"/aws/13-aws-cloudformation","title":"CloudFormation"}}},{"node":{"fields":{"slug":"/aws/12-aws-rdsaurora","title":"RDS Aurora"}}},{"node":{"fields":{"slug":"/security","title":"Security"}}},{"node":{"fields":{"slug":"/","title":"Technology Learning"}}},{"node":{"fields":{"slug":"/security/01-aws-private-ca-private-key","title":"AWS Private CA Private Key"}}}]}},"pageContext":{"id":"01e47731-9b23-5961-afd1-af275dd9bea8"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}