{"componentChunkName":"component---src-templates-docs-js","path":"/concepts/01-apis-security","result":{"data":{"site":{"siteMetadata":{"title":"TechGry","docsLocation":""}},"mdx":{"fields":{"id":"7890b830-fd4a-553a-95f4-d9d952ba2079","title":"API Security","slug":"/concepts/01-apis-security"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"API Security\",\n  \"metaTitle\": \"How to secure APIs ?\",\n  \"metaDescription\": \"How to secure APIs? Very simple way of securing REST APIs.  Global security for REST APIs in Spring Boot\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"How to secure your SpringBoot REST APIs simple way?\"), mdx(\"p\", null, \"Best way to secure your APIs is by adding OAuth2 Authentication/Authorization but that needs an OAuth server established\\nin the first place.  Meanwhile, you can secure your APIs the following simple way.   \"), mdx(\"p\", null, \"You can have a unique secure API key or token for all your services which can be stored in the properties file of\\nspringboot application where your REST end-points reside. Have the below java file which is a servlet filter within\\na separate package like com.concepts.techgry.filter . Since this is a servlet filter every request to this application\\nis intercepted by this filter based on the url pattern thus all the requests to your end-points go through the security\\nlogic defined in this filter.     \"), mdx(\"p\", null, \"There is also an excluded list of url patterns within the servlet filter for which you do not want to apply the\\nsecurity for:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"package com.concepts.techgry.filter;\\n\\nimport com.google.common.base.CharMatcher;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.apache.commons.lang3.StringUtils;\\nimport org.springframework.beans.factory.annotation.Value;\\nimport org.springframework.http.HttpStatus;\\nimport org.springframework.stereotype.Component;\\n\\nimport javax.servlet.*;\\nimport javax.servlet.annotation.WebFilter;\\nimport javax.servlet.http.HttpServletRequest;\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\nimport java.util.Arrays;\\nimport java.util.Base64;\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\n@Slf4j\\n@Component\\n@WebFilter(urlPatterns = \\\"/applicationName/*\\\")\\nclass AuthenticationFilter implements Filter {\\n\\n    final static String BEARER_KEYWORD = \\\"bearer\\\";\\n\\n    final static Set<String> excludeURLPathList = new HashSet<>(Arrays.asList(\\\"/manage/health\\\"));\\n\\n    @Value(\\\"${AUTHORIZATION_KEY}\\\")\\n    private String authorizationKey;\\n\\n    @Override\\n    public void init(FilterConfig filterConfig) throws ServletException {\\n\\n    }\\n\\n    @Override\\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\\n        throws IOException, ServletException {\\n        log.info(\\\"Inside AuthenticationFilter ...\\\");\\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\\n        String authHeader = httpRequest.getHeader(\\\"authorization\\\");\\n        /**\\n         * Incase of request going through proxy (eg: load balancer)\\n         * look for originating client IP in X-Forwarded-For header\\n         * Else retrieve the client IP  via getRemoteAddr()\\n         * */\\n        String remoteAddress = httpRequest.getHeader(\\\"X-Forwarded-For\\\");\\n        String remoteClientAddress = StringUtils.isNotBlank(remoteAddress) ? remoteAddress : httpRequest.getRemoteAddr();\\n        String remoteUserAgent = httpRequest.getHeader(\\\"User-Agent\\\");\\n        String urlPath = httpRequest.getRequestURI().substring( httpRequest.getContextPath().length());\\n        log.info(\\\"RemoteClientAddress : {}, User-Agent: {}, Authorization Header: {}\\\", remoteClientAddress, remoteUserAgent, authHeader);\\n\\n        if (excludeURLPathList.contains(urlPath)) {\\n            log.info(\\\"health check\\\");\\n            chain.doFilter(request, response);\\n        } else if (authorize(authHeader)) {\\n            log.info(\\\"Authorization SUCCESS. RemoteClientAddress : {}, User-Agent: {}, Authorization Header : {}\\\", remoteClientAddress, remoteUserAgent, authHeader);\\n            chain.doFilter(request, response);\\n        }  else {\\n            authenticationFailureResponse(remoteClientAddress, remoteUserAgent, authHeader, response);\\n        }\\n    }\\n\\n    @Override\\n   public void destroy () {\\n\\n    }\\n\\n    static void authenticationFailureResponse(String remoteClientAddress, String remoteUserAgent, String authHeader, ServletResponse response) throws IOException {\\n        log.info(\\\"Authorization FAILURE. RemoteClientAddress : {}, User-Agent: {}, Authorization Header : {}\\\", remoteClientAddress, remoteUserAgent, authHeader);\\n        ((HttpServletResponse) response).setStatus(HttpStatus.UNAUTHORIZED.value());\\n        ((HttpServletResponse) response).getOutputStream().write(\\\"Invalid Authorization Token\\\".getBytes());\\n    }\\n\\n    boolean authorize(String authHeader) {\\n        if(StringUtils.isNotBlank(authHeader)) {\\n            try {\\n                String encodedToken = extractBearerToken(authHeader);\\n                String token = decodeToken(encodedToken);\\n                return token.equals(authorizationKey);\\n            } catch (Exception e) {\\n                log.error(\\\"Exception while authorizing the token\\\", e);\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    static String extractBearerToken(String authHeader) {\\n        if (authHeader.toLowerCase().startsWith(BEARER_KEYWORD)){\\n            return authHeader.substring(BEARER_KEYWORD.length()).trim();\\n        }\\n        return \\\"\\\";\\n    }\\n\\n    static String decodeToken(String encodedToken) {\\n        byte[] decoded = Base64.getDecoder().decode(CharMatcher.whitespace().removeFrom(encodedToken));\\n       return new String(decoded);\\n    }\\n\\n}\\n\\n\")), mdx(\"p\", null, \"Now from the client code which ever service is consuming the end-point will need to embed the Bearer token\\nwithin Authorization headers of the request\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  String authKey = messageSource.getMessage(\\\"properties.auth.key\\\", null, Locale.US);\\n  String base64EncodedAuthKey = Base64.encode(authKey.getBytes(StandardCharsets.UTF_8));\\n\\n  RestTemplate restTemplate = new RestTemplate();\\n  restTemplate.getInterceptors().add((request, body, execution) -> {\\n    request.getHeaders().add(HttpHeaders.AUTHORIZATION, \\\"Bearer \\\" + base64EncodedAuthKey); \\n    return execution.execute(request, body); \\n  });\\n  ResponseObject responseObject = restTemplate.postForObject(requestBaseUrl + \\\"/processRequest\\\", request, ResponseObject.class);\\n\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#how-to-secure-your-springboot-rest-apis-simple-way","title":"How to secure your SpringBoot REST APIs simple way?"}]},"parent":{"__typename":"File","relativePath":"concepts/01-apis-security.mdx"},"frontmatter":{"metaTitle":"How to secure APIs ?","metaDescription":"How to secure APIs? Very simple way of securing REST APIs.  Global security for REST APIs in Spring Boot"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/concepts","title":"RealWorld Concepts"}}},{"node":{"fields":{"slug":"/java","title":"Java"}}},{"node":{"fields":{"slug":"/aws","title":"AWS"}}},{"node":{"fields":{"slug":"/","title":"Technology Learning"}}},{"node":{"fields":{"slug":"/kafka","title":"Kafka Concepts"}}},{"node":{"fields":{"slug":"/kubernetes","title":"Kubernetes Concepts"}}},{"node":{"fields":{"slug":"/pages/about","title":"About TechGry"}}},{"node":{"fields":{"slug":"/pages/terms-and-conditions","title":"Terms and Conditions"}}},{"node":{"fields":{"slug":"/pages/about-me","title":"Vishnu Sunkari"}}},{"node":{"fields":{"slug":"/pages/disclaimer","title":"Disclaimer"}}},{"node":{"fields":{"slug":"/kafka/00-what-is-kafka","title":"What is Kafka"}}},{"node":{"fields":{"slug":"/pages/privacypolicy","title":"Privacy Policy"}}},{"node":{"fields":{"slug":"/kafka/02-kafka-brokers","title":"Brokers"}}},{"node":{"fields":{"slug":"/kubernetes/01-more-pods-on-nodes","title":"How to deploy more pods on kubernetes nodes"}}},{"node":{"fields":{"slug":"/kafka/03-kafka-producers","title":"Producers"}}},{"node":{"fields":{"slug":"/kafka/04-kafka-consumers","title":"Kafka Consumers"}}},{"node":{"fields":{"slug":"/kafka/01-kafka-topics-partitions-offsets","title":"Topics,Partitions & Offsets"}}},{"node":{"fields":{"slug":"/kafka/05-kafka-consumer-offsets-delivery","title":"Consumer Offsets and Delivery Semantics"}}},{"node":{"fields":{"slug":"/kafka/09-kafka-how-to-build-distributed-scalable-system","title":"How to build distributed scalable system with Kafka"}}},{"node":{"fields":{"slug":"/kafka/07-kafka-guarantees","title":"Kafka Guarantees"}}},{"node":{"fields":{"slug":"/kafka/08-kafka-concepts-summary","title":"Kafka Concepts Summary"}}},{"node":{"fields":{"slug":"/java/01-java-functional-programming","title":"Functional Programming"}}},{"node":{"fields":{"slug":"/kafka/06-kafka-broker-discovery-zookeeper","title":"Kafka Broker Discovery and Zookeeper"}}},{"node":{"fields":{"slug":"/java/00-java-classloaders","title":"Java ClassLoaders"}}},{"node":{"fields":{"slug":"/concepts/00-rotation-strategy","title":"Rotate Monthly"}}},{"node":{"fields":{"slug":"/concepts/01-apis-security","title":"API Security"}}},{"node":{"fields":{"slug":"/concepts/02-maxLifetime","title":"Fix HikariPool"}}},{"node":{"fields":{"slug":"/concepts/03-access-spring-beans","title":"Spring Beans"}}},{"node":{"fields":{"slug":"/concepts/04-save-queue-data-on-to-disk","title":"Saving Queue Data on to Disk"}}},{"node":{"fields":{"slug":"/aws/01-aws-organizations","title":"AWS Organizations"}}},{"node":{"fields":{"slug":"/aws/03-aws-service-catalog","title":"AWS Service Catalog"}}},{"node":{"fields":{"slug":"/aws/04-aws-systems-manager","title":"AWS Systems Manager"}}},{"node":{"fields":{"slug":"/aws/00-aws-iam","title":"IAM"}}},{"node":{"fields":{"slug":"/aws/02-aws-config","title":"AWS Config"}}},{"node":{"fields":{"slug":"/aws/05-aws-elastic-load-balancing","title":"Elastic Load Balancing"}}},{"node":{"fields":{"slug":"/aws/06-aws-autoscaling","title":"Autoscaling"}}},{"node":{"fields":{"slug":"/aws/07-aws-placement-groups","title":"Placement Groups"}}},{"node":{"fields":{"slug":"/aws/08-aws-cloudfront","title":"CloudFront"}}},{"node":{"fields":{"slug":"/aws/09-aws-route53","title":"Route53"}}},{"node":{"fields":{"slug":"/aws/10-aws-s3","title":"S3"}}},{"node":{"fields":{"slug":"/aws/11-aws-efs","title":"EFS"}}},{"node":{"fields":{"slug":"/aws/15-aws-elasticbeanstalk","title":"Elastic Beanstalk"}}},{"node":{"fields":{"slug":"/aws/14-aws-opsworks","title":"OpsWorks"}}},{"node":{"fields":{"slug":"/aws/13-aws-cloudformation","title":"CloudFormation"}}},{"node":{"fields":{"slug":"/aws/12-aws-rdsaurora","title":"RDS Aurora"}}},{"node":{"fields":{"slug":"/security","title":"Security"}}}]}},"pageContext":{"id":"7890b830-fd4a-553a-95f4-d9d952ba2079"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}