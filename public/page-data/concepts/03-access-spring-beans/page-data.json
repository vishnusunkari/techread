{"componentChunkName":"component---src-templates-docs-js","path":"/concepts/03-access-spring-beans","result":{"data":{"site":{"siteMetadata":{"title":"TechGry","docsLocation":""}},"mdx":{"fields":{"id":"87697b74-6ebd-5043-82e5-5824216fe6f9","title":"Spring Beans","slug":"/concepts/03-access-spring-beans"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Spring Beans\",\n  \"metaTitle\": \"How to access Spring Beans from Non-Spring managed classes and pojos ?\",\n  \"metaDescription\": \"How to access Spring Beans from Non-Spring managed classes and pojos ? How to make an API call only when  required ? How to avoid making too many API calls ? How to make an API call only when required for every kafka message ?  How to make sure your application is performant when using 3rd party REST API calls ?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"How to access Spring Beans from Non-Spring managed classes and pojos ?\"), mdx(\"p\", null, \"You can easily access spring beans from other spring managed beans by simply Autowiring. But in some cases\\nyou may want to access Spring Beans from a non-Spring managed class or pojo.     \"), mdx(\"p\", null, \"A typical example is when consuming kafka messages lets say we may need the response of a 3rd party REST end-point\\nat multiple places or we may NOT need it at all based on certain if conditions.  So what we were doing initally was calling\\nthat end-point once for every message and using the response data at various required places within the processing of that\\nmessage.  What I found out is that REST end-point's data is only required 500 out of 20000 messages based on certain\\ncriteria of if conditions.  We were unnecessarily calling that end-point for 1500 of the messages.    \"), mdx(\"p\", null, \"For this use case I wanted to call the REST end-point only if required and only once when required per each kafka message\\nand we may be using that response at multiple places within that message processing.  To achieve this use case first you\\nneed the following SpringContext class which can be used to get the spring beans within the current spring context.   \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"package com.concepts.techgry;\\n\\nimport org.springframework.beans.BeansException;\\nimport org.springframework.context.ApplicationContext;\\nimport org.springframework.context.ApplicationContextAware;\\nimport org.springframework.stereotype.Component;\\n\\n/**\\n * @author https://techgry.com\\n * @created 10/29/2021\\n *  NOTE:  This class is used to get a spring bean from IOC container\\n *      to be used for regular java pojo classes.\\n */\\n\\n@Component\\npublic class SpringContext implements ApplicationContextAware {\\n\\n    private static ApplicationContext context;\\n\\n    /**\\n     * Returns the Spring managed bean instance of the given class type if it exists.\\n     * Returns null otherwise.\\n     * @param beanClass\\n     * @return\\n     */\\n    public static <T extends Object> T getBean(Class<T> beanClass) {\\n        return context.getBean(beanClass);\\n    }\\n\\n    @Override\\n    public void setApplicationContext(ApplicationContext context) throws BeansException {\\n\\n        // store ApplicationContext reference to access required beans later on\\n        SpringContext.context = context;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now you can use the above SpringContext class within your pojo to retrieve any spring bean via its static\\ngetBean method. In our example I am getting the RestHelper spring managed bean by which I can make API\\ncalls to the 3rd party REST end-point. Since we wanted to make the API call only when required and only once\\nper each message, make sure you call the end-point within an if condition which is unique to the message, in\\nour example below, customerId is unique to each message and getting pojoMap as response data from API.   \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"package com.concepts.techgry;\\n\\nimport com.concepts.techgry.SpringContext;\\nimport lombok.extern.slf4j.Slf4j;\\n\\nimport java.util.Map;\\n\\n/**\\n * @author https://techgry.com\\n * @created 10/29/2021\\n */\\n\\n/*\\n * NOTE:  This java class should NEVER be made a spring bean as it\\n *      should be initialized for every new kafka message.\\n */\\n@Slf4j\\npublic class Pojo {\\n\\n    private Map<String, String> pojoMap;\\n    private Integer customerId;\\n\\n    public Map<String, String> getPojoMap(Integer customerId) {\\n        if(customerId == null) {\\n            return null;\\n        }\\n        if(this.customerId == null || !this.customerId.equals(customerId)) {\\n            log.info(\\\"YES getPojoMap API CALL for customerId : {} \\\", customerId);\\n            RestHelper restHelper = SpringContext.getBean(RestHelper.class);\\n            this.pojoMap = restHelper.getPojoMap(customerId);\\n            this.customerId = customerId;\\n            if (pojoMap == null || pojoMap.isEmpty()) {\\n                return null;\\n            }\\n        } else {\\n            log.info(\\\"NO getPojoMap API CALL for customerId : {} \\\", customerId);\\n        }\\n        return pojoMap;\\n    }\\n\\n    public String getPojoValue(Integer customerId, String pojoKey){\\n        String value = null;\\n        Map<String, String> pojoMap = getPojoMap(customerId);\\n        if (!pojoMap.isEmpty() && !pojoMap.get(pojoKey).isEmpty()) {\\n            value = pojoMap.get(pojoKey).trim();\\n        }\\n        return value;\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Here is the RestHelper class which is used to make the actual REST API call.   \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"package com.concepts.techgry;\\n\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.beans.factory.annotation.Value;\\nimport org.springframework.http.HttpEntity;\\nimport org.springframework.http.HttpHeaders;\\nimport org.springframework.http.HttpMethod;\\nimport org.springframework.http.ResponseEntity;\\nimport org.springframework.stereotype.Component;\\nimport org.springframework.util.StringUtils;\\nimport org.springframework.web.client.HttpStatusCodeException;\\nimport org.springframework.web.client.ResourceAccessException;\\nimport org.springframework.web.client.RestTemplate;\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n/**\\n * @author https://techgry.com\\n * @created 10/29/2021\\n */\\n\\n@Component\\n@Slf4j\\npublic class RestHelper {\\n\\n    @Value(\\\"${rest.url}\\\")\\n    private String restURL;\\n\\n    @Autowired\\n    RestTemplate restTemplate;\\n\\n    public Map getPojoMap(Integer customerID) {\\n        var objectMapper = new ObjectMapper();\\n        var headers = new HttpHeaders();\\n        headers.add(\\\"Content-Type\\\", \\\"application/json\\\");\\n        try {\\n            HttpEntity<String> request = new HttpEntity<String>(headers);\\n            ResponseEntity<String> responseEntity = restTemplate.exchange(restURL + \\\"?customerID=\\\" + customerID, HttpMethod.POST, request, String.class);\\n            log.info(\\\"RestHelper.getPojoMap API ResponseCode {}, values: {}\\\", responseEntity.getStatusCode(), responseEntity.getBody());\\n            if (responseEntity.getStatusCode().is2xxSuccessful()) {\\n                return objectMapper.readValue(responseEntity.getBody(), HashMap.class);\\n            }\\n        } catch (HttpStatusCodeException e) {\\n            log.error(\\\"RestHelper.HttpStatusCodeException with rest url access for customerID :: {} :: getPojoMap :: {} :: {}\\\", customerID, e.getMessage(), e.getStackTrace());\\n        } catch (ResourceAccessException e) {\\n            log.error(\\\"RestHelper.Issue with P2 url access for customerID :: {} :: getPojoMap :: {} :: {}\\\", customerID, e.getMessage(), e.getStackTrace());\\n        } catch (Exception e) {\\n            log.error(\\\"RestHelper.Failed to getPojoMap for customerID :: {} :: {} :: {}\\\", customerID, e.getMessage(), e.getStackTrace());\\n        }\\n        return null;\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Here is the Client Class or Kafka Consumer   \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\npackage com.concepts.techgry;\\n\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport lombok.extern.slf4j.Slf4j;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.kafka.annotation.KafkaListener;\\nimport org.springframework.kafka.support.Acknowledgment;\\nimport org.springframework.kafka.support.KafkaHeaders;\\nimport org.springframework.messaging.handler.annotation.Header;\\nimport org.springframework.stereotype.Service;\\n\\n/**\\n * @author https://techgry.com\\n * @created 10/29/2021\\n */\\n@Slf4j\\n@Service\\npublic class KafkaConsumer {\\n    \\n    @Autowired\\n    ServiceOne serviceOne;\\n    \\n    @Autowired\\n    ServiceTwo serviceTwo;\\n\\n    @KafkaListener(topics = \\\"#{'${kafka.topic.billingTopic}'}\\\")\\n    public void receive(String record,\\n                        @Header(KafkaHeaders.RECEIVED_PARTITION_ID) Integer partition,\\n                        @Header(KafkaHeaders.OFFSET) Long offset,\\n                        Acknowledgment acknowledgment) {\\n        MessageObj messageObj = mapper.readValue(record, MessageObj.class);\\n        PojoMap pojoMap = new PojoMap();\\n        String customerId = messageObj.getCustomerId();\\n        String keyOne = \\\"key1\\\";\\n        String pojoValueOne = serviceOne.methodOne(customerId, keyOne, pojoMap);\\n        String keyTwo = \\\"key2\\\";\\n        String pojoValueTwo = serviceTwo.methodTwo(customerId, keyTwo, pojoMap);\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Here are the Services within which you would need the response data of REST end-point:   \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"@Service\\npublic class ServiceOne {\\n\\n    public String methodOne(String customerId, String keyOne, PojoMap pojoMap){\\n        String pojoValueOne = pojoMap.getPojoValue(customerId, keyOne);\\n        // do something with pojoValueOne or return it\\n        return pojoValueOne;\\n    }\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"@Service\\npublic class ServiceTwo {\\n\\n    public String methodTwo(String customerId, String keyTwo, PojoMap pojoMap){\\n        String pojoValueTwo = pojoMap.getPojoValue(customerId, keyTwo);\\n        // do something with pojoValueTwo or return it\\n        return pojoValueTwo;\\n    }\\n}\\n\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#how-to-access-spring-beans-from-non-spring-managed-classes-and-pojos-","title":"How to access Spring Beans from Non-Spring managed classes and pojos ?"}]},"parent":{"__typename":"File","relativePath":"concepts/03-access-spring-beans.mdx"},"frontmatter":{"metaTitle":"How to access Spring Beans from Non-Spring managed classes and pojos ?","metaDescription":"How to access Spring Beans from Non-Spring managed classes and pojos ? How to make an API call only when  required ? How to avoid making too many API calls ? How to make an API call only when required for every kafka message ?  How to make sure your application is performant when using 3rd party REST API calls ?"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/concepts","title":"RealWorld Concepts"}}},{"node":{"fields":{"slug":"/java","title":"Java"}}},{"node":{"fields":{"slug":"/aws","title":"AWS"}}},{"node":{"fields":{"slug":"/kafka","title":"Kafka Concepts"}}},{"node":{"fields":{"slug":"/kubernetes","title":"Kubernetes Concepts"}}},{"node":{"fields":{"slug":"/pages/about","title":"About TechGry"}}},{"node":{"fields":{"slug":"/pages/terms-and-conditions","title":"Terms and Conditions"}}},{"node":{"fields":{"slug":"/pages/about-me","title":"Vishnu Sunkari"}}},{"node":{"fields":{"slug":"/pages/disclaimer","title":"Disclaimer"}}},{"node":{"fields":{"slug":"/kafka/00-what-is-kafka","title":"What is Kafka"}}},{"node":{"fields":{"slug":"/pages/privacypolicy","title":"Privacy Policy"}}},{"node":{"fields":{"slug":"/kafka/02-kafka-brokers","title":"Brokers"}}},{"node":{"fields":{"slug":"/kubernetes/01-more-pods-on-nodes","title":"How to deploy more pods on kubernetes nodes"}}},{"node":{"fields":{"slug":"/kafka/03-kafka-producers","title":"Producers"}}},{"node":{"fields":{"slug":"/kafka/04-kafka-consumers","title":"Kafka Consumers"}}},{"node":{"fields":{"slug":"/kafka/01-kafka-topics-partitions-offsets","title":"Topics,Partitions & Offsets"}}},{"node":{"fields":{"slug":"/kafka/05-kafka-consumer-offsets-delivery","title":"Consumer Offsets and Delivery Semantics"}}},{"node":{"fields":{"slug":"/kafka/09-kafka-how-to-build-distributed-scalable-system","title":"How to build distributed scalable system with Kafka"}}},{"node":{"fields":{"slug":"/kafka/07-kafka-guarantees","title":"Kafka Guarantees"}}},{"node":{"fields":{"slug":"/kafka/08-kafka-concepts-summary","title":"Kafka Concepts Summary"}}},{"node":{"fields":{"slug":"/java/01-java-functional-programming","title":"Functional Programming"}}},{"node":{"fields":{"slug":"/kafka/06-kafka-broker-discovery-zookeeper","title":"Kafka Broker Discovery and Zookeeper"}}},{"node":{"fields":{"slug":"/java/00-java-classloaders","title":"Java ClassLoaders"}}},{"node":{"fields":{"slug":"/concepts/00-rotation-strategy","title":"Rotate Monthly"}}},{"node":{"fields":{"slug":"/concepts/01-apis-security","title":"API Security"}}},{"node":{"fields":{"slug":"/concepts/02-maxLifetime","title":"Fix HikariPool"}}},{"node":{"fields":{"slug":"/concepts/03-access-spring-beans","title":"Spring Beans"}}},{"node":{"fields":{"slug":"/concepts/04-save-queue-data-on-to-disk","title":"Saving Queue Data on to Disk"}}},{"node":{"fields":{"slug":"/aws/01-aws-organizations","title":"AWS Organizations"}}},{"node":{"fields":{"slug":"/aws/03-aws-service-catalog","title":"AWS Service Catalog"}}},{"node":{"fields":{"slug":"/aws/04-aws-systems-manager","title":"AWS Systems Manager"}}},{"node":{"fields":{"slug":"/aws/00-aws-iam","title":"IAM"}}},{"node":{"fields":{"slug":"/aws/02-aws-config","title":"AWS Config"}}},{"node":{"fields":{"slug":"/aws/05-aws-elastic-load-balancing","title":"Elastic Load Balancing"}}},{"node":{"fields":{"slug":"/aws/06-aws-autoscaling","title":"Autoscaling"}}},{"node":{"fields":{"slug":"/aws/07-aws-placement-groups","title":"Placement Groups"}}},{"node":{"fields":{"slug":"/aws/08-aws-cloudfront","title":"CloudFront"}}},{"node":{"fields":{"slug":"/aws/09-aws-route53","title":"Route53"}}},{"node":{"fields":{"slug":"/aws/10-aws-s3","title":"S3"}}},{"node":{"fields":{"slug":"/aws/11-aws-efs","title":"EFS"}}},{"node":{"fields":{"slug":"/aws/15-aws-elasticbeanstalk","title":"Elastic Beanstalk"}}},{"node":{"fields":{"slug":"/aws/14-aws-opsworks","title":"OpsWorks"}}},{"node":{"fields":{"slug":"/aws/13-aws-cloudformation","title":"CloudFormation"}}},{"node":{"fields":{"slug":"/aws/12-aws-rdsaurora","title":"RDS Aurora"}}},{"node":{"fields":{"slug":"/security","title":"Security"}}},{"node":{"fields":{"slug":"/","title":"Technology Learning"}}},{"node":{"fields":{"slug":"/security/01-aws-private-ca-private-key","title":"AWS Private CA Private Key"}}}]}},"pageContext":{"id":"87697b74-6ebd-5043-82e5-5824216fe6f9"}},"staticQueryHashes":["2619113677","2619113677","3706406642","3706406642","417421954","417421954"]}